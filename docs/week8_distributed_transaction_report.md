# MSA 전환 시 트랜잭션 관리 전략 및 해결 방안

---

## 1. 기존 시스템 트랜잭션 처리 방식
기존 모놀리식 아키텍처에서는 **단일 데이터베이스**를 사용하여 트랜잭션을 관리한다.

- **ACID 트랜잭션 적용** (Atomicity, Consistency, Isolation, Durability)
- `@Transactional`을 사용하여 **트랜잭션 내에서 여러 서비스 호출을 보장**
- 데이터 정합성이 보장되며, 실패 시 **전체 롤백 가능**

### 문제점
- 서비스가 확장될수록 **트랜잭션 Lock 경합 증가**
- 하나의 DB에 모든 서비스가 의존하므로 **스케일 아웃이 어려움**
- 하나의 서비스 장애가 전체 시스템에 영향을 미침

---

## 2. MSA 전환 시 트랜잭션 처리의 한계
### 1. 분산 트랜잭션(Distributed Transaction) 관리의 어려움
각 서비스가 개별적인 데이터 저장소를 가지므로 **단일 트랜잭션으로 관리할 수 없다**.

예를 들어, **Order 서비스에서 Payment 서비스로 요청을 보냈을 때 하나가 실패하면 전체를 롤백하기 어렵다**.

### 2. 2PC(XA 트랜잭션)의 비효율성
**2-Phase Commit(2PC)** 을 사용하여 분산 트랜잭션을 관리할 수 있지만
- 네트워크 및 DB 락이 증가하여 성능 저하 발생
- 서비스 간 결합도가 높아지며 확장성이 떨어짐
- 장애 발생 시 복구가 어려움

### 3. 데이터 정합성 문제 발생
- **A 서비스에서는 성공했지만, B 서비스에서는 실패**할 경우 데이터 불일치가 발생
- **Dirty Read, Lost Update** 같은 정합성 문제가 발생할 가능성이 높음

### 4. 롤백 어려움
기존 트랜잭션에서는 `@Transactional`을 통해 롤백할 수 있지만,
- MSA 환경에서는 **서비스별로 트랜잭션이 독립적으로 실행되므로** 롤백이 어려움
- **이미 일부 서비스가 커밋된 경우 복구가 어려움**

---

## 3. 분산 트랜잭션 해결 방안
### 1. SAGA 패턴 (보상 트랜잭션)
- 트랜잭션이 실패하면 **보상 트랜잭션(Compensation Transaction)** 을 실행하여 정합성을 유지
- 예를 들어 **주문 생성 후 결제가 실패하면 주문을 취소하는 방식**

#### (1) 오케스트레이션(Orchestration)
- **중앙 컨트롤러(Service Orchestrator)** 가 각 서비스의 트랜잭션을 관리
- 성공하면 다음 서비스 호출, 실패하면 보상 트랜잭션 실행

#### (2) 코레오그래피(Choreography)
- 각 서비스가 이벤트를 통해 다음 트랜잭션을 호출
- Kafka, RabbitMQ 같은 메시지 브로커를 사용하여 비동기 트랜잭션 수행

#### 장점
- 네트워크 지연이 적고 서비스 간 결합도가 낮음

#### 단점
- 보상 트랜잭션을 설계해야 하므로 복잡성이 증가

---

### 2. 이벤트 기반 트랜잭션 (Eventually Consistent)
- **이벤트를 통해 트랜잭션을 비동기적으로 관리**
- Outbox 패턴, CDC(Change Data Capture) 사용

#### (1) Outbox 패턴
- **트랜잭션과 함께 Outbox 테이블에 이벤트 저장**
- 별도의 이벤트 처리기가 Outbox 테이블을 읽어 Kafka에 전송

#### (2) CDC(Change Data Capture) 사용 
- **Debezium 같은 CDC 도구** 를 활용하여 **DB 변경 사항을 감지하고 이벤트 생성**

#### 장점
- 트랜잭션 간 결합도 감소, 확장성 증가

#### 단점
- 실시간 일관성이 부족할 수 있음

---

### 3. TCC(Try-Confirm-Cancle) 패턴
- 트랜잭션을 **Try(준비) - Confirm(확정) - Cancel(취소)** 단계로 나누어 처리
- 금융, 결제 시스템과 같이 **엄격한 데이터 일관성이 필요한 경우** 에 적합 

#### 장점
- 높은 데이터 일관성 유지

#### 단점
- 비즈니스 로직이 복잡해질 수 있음

---

## 4. 결론
- 트랜잭션 강도가 높은 서비스는 **TCC 패턴** 적용
- 일반적인 트랜잭션은 Saga 패턴 (오케스트레이션 or 코레오그래피) 활용
- 이벤트 기반 시스템을 적극 활용하여 결과적 일관성 보장
- Kafka, RabbitMQ, Debezium 등을 도입하여 안정적인 데이터 흐름 구축